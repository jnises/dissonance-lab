use wmidi::Note;

use crate::piano_types::{ExternalKeySet, KeySet, Semitone};

/// Actions that can be generated by the piano state
#[derive(Debug, Clone, PartialEq)]
pub enum Action {
    Pressed(wmidi::Note),
    Released(wmidi::Note),
    SustainPedal(bool),
}

/// The core business logic state for piano key management, sustain logic, and action generation.
/// This struct is separate from GUI concerns and can be unit tested independently.
pub struct PianoState {
    /// Keys that had GUI input in the previous frame.
    /// Used to detect press/release transitions for action generation.
    /// Does NOT include sustained keys or keys held via external MIDI input.
    previous_gui_pressed_keys: KeySet,

    /// Keys that are currently pressed via GUI input.
    /// This represents the current state of GUI key presses.
    current_gui_pressed_keys: KeySet,

    /// Keys that were pressed via GUI while sustain was active, but have since been released.
    /// These keys will remain active until the sustain pedal is released.
    sustained_keys: KeySet,

    /// Keys that are currently pressed via external MIDI input.
    /// Tracks all 128 MIDI notes, not just the current octave.
    external_pressed_keys: ExternalKeySet,

    /// Keys that are sustained due to sustain pedal being active when they were released.
    /// These keys will remain active until the sustain pedal is released.
    external_sustained_keys: ExternalKeySet,

    /// The octave that this piano state operates on (default: 4, meaning C4-B4)
    octave: u8,

    /// Whether the shift key was active in the previous frame
    previous_shift_sustain_active: bool,

    /// Whether the shift key is currently active
    shift_sustain_active: bool,

    /// Whether external MIDI sustain is currently active
    external_sustain_active: bool,
}

impl PianoState {
    pub fn new() -> Self {
        const DEFAULT_OCTAVE: u8 = 4;

        Self {
            previous_gui_pressed_keys: Default::default(),
            current_gui_pressed_keys: Default::default(),
            sustained_keys: Default::default(),
            external_pressed_keys: Default::default(),
            external_sustained_keys: Default::default(),
            octave: DEFAULT_OCTAVE,
            previous_shift_sustain_active: false,
            shift_sustain_active: false,
            external_sustain_active: false,
        }
    }

    /// Update the GUI pressed keys state and generate appropriate actions
    pub fn update_gui_keys(&mut self, pressed_keys: KeySet, actions: &mut Vec<Action>) {
        self.current_gui_pressed_keys = pressed_keys;
        self.generate_actions_for_gui_keys(actions);
    }

    /// Update the shift sustain state and generate appropriate actions
    pub fn update_shift_sustain(&mut self, active: bool, actions: &mut Vec<Action>) {
        let was_overall_sustain_active = self.is_sustain_active();
        self.shift_sustain_active = active;
        let is_overall_sustain_active = self.is_sustain_active();

        // Generate sustain pedal action if overall sustain state changed
        if was_overall_sustain_active != is_overall_sustain_active {
            actions.push(Action::SustainPedal(is_overall_sustain_active));
        }

        // Update previous shift sustain state for next comparison
        self.previous_shift_sustain_active = active;

        if !active {
            // Handle sustain pedal release for external keys
            self.handle_sustain_release_for_external_keys();

            // Handle sustain release for GUI keys
            self.handle_shift_sustain_release(actions);
        }
    }

    /// Add external MIDI note press
    pub fn external_note_on(&mut self, note: Note) {
        let note_value = u8::from(note) as usize;
        debug_assert!(note_value < 128, "MIDI note value must be < 128");
        self.external_pressed_keys.set(note_value, true);
        // If this note was sustained, remove it from sustained set since it's now actively pressed
        self.external_sustained_keys.set(note_value, false);
    }

    /// Handle external MIDI note release
    pub fn external_note_off(&mut self, note: Note) {
        let note_value = u8::from(note) as usize;
        debug_assert!(note_value < 128, "MIDI note value must be < 128");

        // Always remove from pressed keys first
        self.external_pressed_keys.set(note_value, false);

        if self.is_sustain_active() {
            // If sustain is active, move the key to sustained set
            self.external_sustained_keys.set(note_value, true);
        }
        // If sustain is not active, the key is simply released (removed from pressed keys above)
    }

    /// Set external sustain pedal state (from MIDI input)
    pub fn set_external_sustain(&mut self, active: bool, actions: &mut Vec<Action>) {
        let was_overall_sustain_active = self.is_sustain_active();
        self.external_sustain_active = active;
        let is_overall_sustain_active = self.is_sustain_active();
        
        // Generate sustain pedal action if overall sustain state changed
        if was_overall_sustain_active != is_overall_sustain_active {
            actions.push(Action::SustainPedal(is_overall_sustain_active));
        }
        
        if !active {
            // When sustain is released, clear all sustained external keys
            self.handle_sustain_release_for_external_keys();
        }
    }

    /// Check if sustain is currently active (either from Shift key or MIDI)
    pub fn is_sustain_active(&self) -> bool {
        self.shift_sustain_active || self.external_sustain_active
    }

    /// Get all keys currently held in some way, from GUI or from MIDI, actively pressed or sustained
    pub fn held_keys(&self) -> KeySet {
        let mut keys = self.current_gui_pressed_keys;

        // Add sustained GUI keys
        for sustained_key in self.sustained_keys.iter_ones() {
            keys.set(sustained_key, true);
        }

        // Add currently active external keys
        for external_key in self.external_pressed_keys.iter_ones() {
            keys.set(external_key % 12, true);
        }

        // Add sustained external keys
        for sustained_key in self.external_sustained_keys.iter_ones() {
            keys.set(sustained_key % 12, true);
        }

        keys
    }

    /// Get the current octave
    pub fn octave(&self) -> u8 {
        self.octave
    }

    /// Get keys that are sustained via GUI (were pressed while sustain was active, now released)
    pub fn gui_sustained_keys(&self) -> &KeySet {
        &self.sustained_keys
    }

    /// Check if a specific semitone is pressed via external MIDI in any octave
    pub fn is_external_pressed(&self, semitone: Semitone) -> bool {
        let target_semitone = semitone.as_index();
        // Check all octaves for this semitone
        for note_value in self.external_pressed_keys.iter_ones() {
            if note_value % 12 == target_semitone {
                return true;
            }
        }
        false
    }

    /// Check if a specific semitone is sustained via external MIDI in any octave
    pub fn is_external_sustained(&self, semitone: Semitone) -> bool {
        let target_semitone = semitone.as_index();
        // Check all octaves for this semitone
        for note_value in self.external_sustained_keys.iter_ones() {
            if note_value % 12 == target_semitone {
                return true;
            }
        }
        false
    }

    /// Generate actions for GUI key state changes
    fn generate_actions_for_gui_keys(&mut self, actions: &mut Vec<Action>) {
        for semitone in Semitone::iter() {
            let note = semitone.to_note_in_octave(self.octave);
            let semitone_index = semitone.as_index();

            let is_pressed = self.current_gui_pressed_keys[semitone_index];
            let was_pressed = self.previous_gui_pressed_keys[semitone_index];

            if is_pressed && !was_pressed {
                actions.push(Action::Pressed(note));
                // If this key was sustained, remove it from sustained set since it's now actively pressed
                self.sustained_keys.set(semitone_index, false);
            } else if !is_pressed && was_pressed {
                if self.is_sustain_active() {
                    // If sustain is active, move to sustained but don't generate Action::Released
                    self.sustained_keys.set(semitone_index, true);
                } else {
                    // If sustain is not active, generate release action and clear sustained
                    actions.push(Action::Released(note));
                    self.sustained_keys.set(semitone_index, false);
                }
            }
        }

        // Update previous state for next frame
        self.previous_gui_pressed_keys = self.current_gui_pressed_keys;
    }

    /// Handle shift sustain release - release all sustained GUI keys that aren't currently pressed
    fn handle_shift_sustain_release(&mut self, actions: &mut Vec<Action>) {
        for semitone in Semitone::iter() {
            let semitone_index = semitone.as_index();
            let note = semitone.to_note_in_octave(self.octave);
            let is_currently_pressed = self.current_gui_pressed_keys[semitone_index];

            // Clear sustained selection if key is not currently being pressed
            if !is_currently_pressed && self.sustained_keys[semitone_index] {
                self.sustained_keys.set(semitone_index, false);
                actions.push(Action::Released(note));
            }
        }
    }

    /// Handle sustain pedal release for external (MIDI) keys
    /// Clear all sustained external keys when sustain is released
    fn handle_sustain_release_for_external_keys(&mut self) {
        // Clear all sustained external keys - they should no longer be sustained
        self.external_sustained_keys.fill(false);
    }
}

impl Default for PianoState {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_new_piano_state() {
        let state = PianoState::new();
        assert!(!state.is_sustain_active());
        assert!(state.held_keys().iter_ones().collect::<Vec<_>>().is_empty());
    }

    #[test]
    fn test_gui_key_press_and_release() {
        let mut state = PianoState::new();

        // Press C key (semitone 0)
        let mut pressed_keys = KeySet::default();
        pressed_keys.set(0, true);
        let mut actions = Vec::new();
        state.update_gui_keys(pressed_keys, &mut actions);

        assert_eq!(actions.len(), 1);
        assert!(matches!(actions[0], Action::Pressed(_)));
        assert!(state.held_keys()[0]);

        // Release C key
        let pressed_keys = KeySet::default();
        let mut actions = Vec::new();
        state.update_gui_keys(pressed_keys, &mut actions);

        assert_eq!(actions.len(), 1);
        assert!(matches!(actions[0], Action::Released(_)));
        assert!(!state.held_keys()[0]);
    }

    #[test]
    fn test_gui_input_shows_in_gui_and_generates_actions() {
        let mut state = PianoState::new();

        // Test pressing multiple keys via GUI
        let mut pressed_keys = KeySet::default();
        pressed_keys.set(0, true); // C
        pressed_keys.set(4, true); // E
        pressed_keys.set(7, true); // G
        let mut actions = Vec::new();
        state.update_gui_keys(pressed_keys, &mut actions);

        // Should generate one Pressed action for each key
        assert_eq!(actions.len(), 3);
        assert!(
            actions
                .iter()
                .all(|action| matches!(action, Action::Pressed(_)))
        );

        // All pressed keys should show up in held_keys (what appears in GUI)
        let held = state.held_keys();
        assert!(held[0]); // C
        assert!(held[4]); // E
        assert!(held[7]); // G
        assert!(!held[1]); // D should not be held

        // Release one key via GUI
        let mut pressed_keys = KeySet::default();
        pressed_keys.set(0, true); // C still pressed
        pressed_keys.set(7, true); // G still pressed
        // E (index 4) is released
        let mut actions = Vec::new();
        state.update_gui_keys(pressed_keys, &mut actions);

        // Should generate one Released action for E
        assert_eq!(actions.len(), 1);
        assert!(matches!(actions[0], Action::Released(_)));

        // Only C and G should show up in held_keys now
        let held = state.held_keys();
        assert!(held[0]); // C
        assert!(!held[4]); // E should no longer be held
        assert!(held[7]); // G
    }

    #[test]
    fn test_sustain_behavior() {
        let mut state = PianoState::new();

        // Activate sustain
        let mut actions = Vec::new();
        state.update_shift_sustain(true, &mut actions);
        assert_eq!(actions.len(), 1);
        assert_eq!(actions[0], Action::SustainPedal(true));
        assert!(state.is_sustain_active());

        // Press and release C key while sustain is active
        let mut pressed_keys = KeySet::default();
        pressed_keys.set(0, true);
        let mut actions = Vec::new();
        state.update_gui_keys(pressed_keys, &mut actions);
        assert_eq!(actions.len(), 1);
        assert!(matches!(actions[0], Action::Pressed(_)));

        // Release key while sustain is active - should not generate release action
        let pressed_keys = KeySet::default();
        let mut actions = Vec::new();
        state.update_gui_keys(pressed_keys, &mut actions);
        assert!(actions.is_empty());
        assert!(state.held_keys()[0]); // Key should still be held due to sustain

        // Release sustain - should generate release action
        let mut actions = Vec::new();
        state.update_shift_sustain(false, &mut actions);
        assert_eq!(actions.len(), 2);
        assert_eq!(actions[0], Action::SustainPedal(false));
        assert!(matches!(actions[1], Action::Released(_)));
        assert!(!state.held_keys()[0]);
    }

    #[test]
    fn test_external_midi_notes() {
        let mut state = PianoState::new();

        // Add external note
        let note = Note::try_from(60).unwrap(); // C4
        state.external_note_on(note);
        assert!(state.held_keys()[0]); // C semitone should be held

        // Release external note
        state.external_note_off(note);
        assert!(!state.held_keys()[0]); // Should no longer be held
    }

    #[test]
    fn test_shift_sustain_generates_sustain_pedal_actions() {
        let mut state = PianoState::new();

        // Activating shift sustain should generate SustainPedal(true) action
        let mut actions = Vec::new();
        state.update_shift_sustain(true, &mut actions);

        assert_eq!(actions.len(), 1);
        assert_eq!(actions[0], Action::SustainPedal(true));
        assert!(state.is_sustain_active());

        // Deactivating shift sustain should generate SustainPedal(false) action
        let mut actions = Vec::new();
        state.update_shift_sustain(false, &mut actions);

        assert_eq!(actions.len(), 1);
        assert_eq!(actions[0], Action::SustainPedal(false));
        assert!(!state.is_sustain_active());

        // Activating again should generate SustainPedal(true) action
        let mut actions = Vec::new();
        state.update_shift_sustain(true, &mut actions);

        assert_eq!(actions.len(), 1);
        assert_eq!(actions[0], Action::SustainPedal(true));
        assert!(state.is_sustain_active());
    }

    #[test]
    fn test_pressing_sustained_key_generates_only_pressed_action() {
        let mut state = PianoState::new();

        // First activate sustain
        let mut actions = Vec::new();
        state.update_shift_sustain(true, &mut actions);
        actions.clear(); // Clear sustain pedal action

        // Press C key via GUI
        let mut pressed_keys = KeySet::default();
        pressed_keys.set(0, true); // C
        let mut actions = Vec::new();
        state.update_gui_keys(pressed_keys, &mut actions);

        assert_eq!(actions.len(), 1);
        assert!(matches!(actions[0], Action::Pressed(_)));
        assert!(state.held_keys()[0]); // C should be held

        // Release C key while sustain is active - should become sustained
        let pressed_keys = KeySet::default();
        let mut actions = Vec::new();
        state.update_gui_keys(pressed_keys, &mut actions);

        assert!(actions.is_empty()); // No release action due to sustain
        assert!(state.held_keys()[0]); // C should still be held (sustained)

        // Now press C key again while it's sustained - should generate only Pressed action
        let mut pressed_keys = KeySet::default();
        pressed_keys.set(0, true); // C pressed again
        let mut actions = Vec::new();
        state.update_gui_keys(pressed_keys, &mut actions);

        // Should generate only Action::Pressed (no retriggering)
        assert_eq!(actions.len(), 1);
        assert!(matches!(actions[0], Action::Pressed(_)));
        assert!(state.held_keys()[0]); // C should still be held (now actively pressed)
    }

    #[test]
    fn test_external_sustain() {
        let mut state = PianoState::new();
        let mut actions = Vec::new();

        // Set external sustain active
        state.set_external_sustain(true, &mut actions);
        assert!(state.is_sustain_active());

        // Add and release external note while sustain is active
        let note = Note::try_from(60).unwrap(); // C4
        state.external_note_on(note);
        assert!(state.held_keys()[0]);

        state.external_note_off(note);
        assert!(state.held_keys()[0]); // Should still be held due to sustain

        // Release external sustain
        actions.clear();
        state.set_external_sustain(false, &mut actions);
        assert!(!state.is_sustain_active());
        assert!(!state.held_keys()[0]); // Should no longer be held
    }

    #[test]
    fn test_mixed_sustain_sources() {
        let mut state = PianoState::new();
        let mut actions = Vec::new();

        // Activate both shift and external sustain
        state.update_shift_sustain(true, &mut actions);
        // Should generate one sustain action when first source becomes active
        assert_eq!(actions.len(), 1);
        assert!(matches!(actions[0], Action::SustainPedal(true)));
        
        actions.clear();
        state.set_external_sustain(true, &mut actions);
        // Should not generate sustain action since sustain was already active
        assert_eq!(actions.len(), 0);
        assert!(state.is_sustain_active());

        // Release shift sustain - should still be active due to external
        actions.clear();
        state.update_shift_sustain(false, &mut actions);
        // Should not generate sustain action since external sustain keeps it active
        assert_eq!(actions.len(), 0);
        assert!(state.is_sustain_active());

        // Release external sustain - should no longer be active
        actions.clear();
        state.set_external_sustain(false, &mut actions);
        // Should generate sustain release action since both sources are now inactive
        assert_eq!(actions.len(), 1);
        assert!(matches!(actions[0], Action::SustainPedal(false)));
        assert!(!state.is_sustain_active());
    }

    #[test]
    fn test_sustain_combination_order_independence() {
        // Test that the order of activating/deactivating sustain sources doesn't matter
        
        // Test external first, then shift
        let mut state1 = PianoState::new();
        let mut actions1 = Vec::new();
        
        state1.set_external_sustain(true, &mut actions1);
        assert_eq!(actions1.len(), 1);
        assert!(matches!(actions1[0], Action::SustainPedal(true)));
        
        actions1.clear();
        state1.update_shift_sustain(true, &mut actions1);
        assert_eq!(actions1.len(), 0); // No new action since sustain was already active
        
        // Test shift first, then external  
        let mut state2 = PianoState::new();
        let mut actions2 = Vec::new();
        
        state2.update_shift_sustain(true, &mut actions2);
        assert_eq!(actions2.len(), 1);
        assert!(matches!(actions2[0], Action::SustainPedal(true)));
        
        actions2.clear();
        state2.set_external_sustain(true, &mut actions2);
        assert_eq!(actions2.len(), 0); // No new action since sustain was already active
        
        // Both should have the same final state
        assert_eq!(state1.is_sustain_active(), state2.is_sustain_active());
    }

    #[test]
    fn test_external_notes_show_in_gui_regardless_of_octave() {
        let mut state = PianoState::new();

        // Test C notes from different octaves - they should all show as C in the GUI
        let c2 = Note::C2; // MIDI note 36
        let c4 = Note::C4; // MIDI note 60 (default octave)
        let c6 = Note::C6; // MIDI note 84

        // Press C2 - should show as C in GUI
        state.external_note_on(c2);
        let held_keys = state.held_keys();
        assert!(
            held_keys[Semitone::C.as_index()],
            "C2 should show as C in GUI"
        );

        // Press C4 - should also show as C in GUI (no change since C is already held)
        state.external_note_on(c4);
        let held_keys = state.held_keys();
        assert!(
            held_keys[Semitone::C.as_index()],
            "C4 should show as C in GUI"
        );

        // Press C6 - should also show as C in GUI
        state.external_note_on(c6);
        let held_keys = state.held_keys();
        assert!(
            held_keys[Semitone::C.as_index()],
            "C6 should show as C in GUI"
        );

        // Release C2 - C should still be held due to C4 and C6
        state.external_note_off(c2);
        let held_keys = state.held_keys();
        assert!(
            held_keys[Semitone::C.as_index()],
            "C should still be held after releasing C2"
        );

        // Release C4 - C should still be held due to C6
        state.external_note_off(c4);
        let held_keys = state.held_keys();
        assert!(
            held_keys[Semitone::C.as_index()],
            "C should still be held after releasing C4"
        );

        // Release C6 - C should no longer be held
        state.external_note_off(c6);
        let held_keys = state.held_keys();
        assert!(
            !held_keys[Semitone::C.as_index()],
            "C should not be held after releasing all C notes"
        );

        // Test with different notes from different octaves
        let f_sharp_1 = Note::FSharp1; // MIDI note 30
        let f_sharp_5 = Note::FSharp5; // MIDI note 78

        state.external_note_on(f_sharp_1);
        state.external_note_on(f_sharp_5);
        let held_keys = state.held_keys();
        assert!(
            held_keys[Semitone::F_SHARP.as_index()],
            "F# from different octaves should show as F# in GUI"
        );

        // Release one F# - should still be held
        state.external_note_off(f_sharp_1);
        let held_keys = state.held_keys();
        assert!(
            held_keys[Semitone::F_SHARP.as_index()],
            "F# should still be held after releasing F#1"
        );

        // Release the other F# - should no longer be held
        state.external_note_off(f_sharp_5);
        let held_keys = state.held_keys();
        assert!(
            !held_keys[Semitone::F_SHARP.as_index()],
            "F# should not be held after releasing all F# notes"
        );
    }

    #[test]
    fn test_is_external_pressed_and_sustained_across_octaves() {
        let mut state = PianoState::new();

        // Test that is_external_pressed works across octaves
        let c2 = Note::C2; // MIDI note 36
        let c6 = Note::C6; // MIDI note 84

        // Press C2 - should be detected as C pressed
        state.external_note_on(c2);
        assert!(
            state.is_external_pressed(Semitone::C),
            "C2 should be detected as C pressed"
        );

        // Press C6 as well
        state.external_note_on(c6);
        assert!(
            state.is_external_pressed(Semitone::C),
            "C should still be detected as pressed with both C2 and C6"
        );

        // Release C2, C should still be pressed due to C6
        state.external_note_off(c2);
        assert!(
            state.is_external_pressed(Semitone::C),
            "C should still be pressed after releasing C2"
        );

        // Release C6, C should no longer be pressed
        state.external_note_off(c6);
        assert!(
            !state.is_external_pressed(Semitone::C),
            "C should not be pressed after releasing all C notes"
        );

        // Test sustain across octaves
        let mut actions = Vec::new();
        state.set_external_sustain(true, &mut actions);

        // Press and release C2 while sustain is active
        state.external_note_on(c2);
        state.external_note_off(c2);
        assert!(
            state.is_external_sustained(Semitone::C),
            "C should be sustained after releasing C2 with sustain active"
        );

        // Press and release C6 while sustain is active
        state.external_note_on(c6);
        state.external_note_off(c6);
        assert!(
            state.is_external_sustained(Semitone::C),
            "C should still be sustained with both C2 and C6 sustained"
        );

        // Release sustain
        actions.clear();
        state.set_external_sustain(false, &mut actions);
        assert!(
            !state.is_external_sustained(Semitone::C),
            "C should not be sustained after releasing sustain"
        );
    }
}
