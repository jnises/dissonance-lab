use wmidi::Note;

use crate::piano_types::{ExternalKeySet, KeySet, Semitone};

/// Actions that can be generated by the piano state
#[allow(dead_code)] // TODO: Remove when integrated with PianoGui
#[derive(Debug, Clone, PartialEq)]
pub enum Action {
    Pressed(wmidi::Note),
    Released(wmidi::Note),
    SustainPedal(bool),
}

/// The core business logic state for piano key management, sustain logic, and action generation.
/// This struct is separate from GUI concerns and can be unit tested independently.
#[allow(dead_code)] // TODO: Remove when integrated with PianoGui
pub struct PianoState {
    /// Keys that had GUI input in the previous frame.
    /// Used to detect press/release transitions for action generation.
    /// Does NOT include sustained keys or keys held via external MIDI input.
    previous_gui_pressed_keys: KeySet,

    /// Keys that are currently pressed via GUI input.
    /// This represents the current state of GUI key presses.
    current_gui_pressed_keys: KeySet,

    /// Keys that were pressed via GUI while sustain was active, but have since been released.
    /// These keys will remain active until the sustain pedal is released.
    sustained_keys: KeySet,

    /// Keys that are currently pressed via external MIDI input.
    /// Tracks all 128 MIDI notes, not just the current octave.
    external_pressed_keys: ExternalKeySet,

    /// Keys that are sustained due to sustain pedal being active when they were released.
    /// These keys will remain active until the sustain pedal is released.
    external_sustained_keys: ExternalKeySet,

    /// The octave that this piano state operates on (default: 4, meaning C4-B4)
    octave: u8,

    /// Whether the shift key was active in the previous frame
    previous_shift_sustain_active: bool,

    /// Whether the shift key is currently active
    shift_sustain_active: bool,

    /// Whether external MIDI sustain is currently active
    external_sustain_active: bool,
}

#[allow(dead_code)] // TODO: Remove when integrated with PianoGui
impl PianoState {
    pub fn new() -> Self {
        const DEFAULT_OCTAVE: u8 = 4;

        Self {
            previous_gui_pressed_keys: Default::default(),
            current_gui_pressed_keys: Default::default(),
            sustained_keys: Default::default(),
            external_pressed_keys: Default::default(),
            external_sustained_keys: Default::default(),
            octave: DEFAULT_OCTAVE,
            previous_shift_sustain_active: false,
            shift_sustain_active: false,
            external_sustain_active: false,
        }
    }

    /// Update the GUI pressed keys state and generate appropriate actions
    pub fn update_gui_keys(&mut self, pressed_keys: KeySet) -> Vec<Action> {
        self.current_gui_pressed_keys = pressed_keys;
        self.generate_actions_for_gui_keys()
    }

    /// Update the shift sustain state and generate appropriate actions
    pub fn update_shift_sustain(&mut self, active: bool) -> Vec<Action> {
        let mut actions = Vec::new();

        self.shift_sustain_active = active;

        // Generate sustain pedal action if state changed
        if active != self.previous_shift_sustain_active {
            actions.push(Action::SustainPedal(active));
            self.previous_shift_sustain_active = active;

            if !active {
                // Handle sustain pedal release for external keys
                self.handle_sustain_release_for_external_keys();

                // Handle sustain release for GUI keys
                actions.extend(self.handle_shift_sustain_release());
            }
        }

        actions
    }

    /// Add external MIDI note press
    pub fn external_note_on(&mut self, note: Note) {
        let note_value = u8::from(note) as usize;
        debug_assert!(note_value < 128, "MIDI note value must be < 128");
        self.external_pressed_keys.set(note_value, true);
        // If this note was sustained, remove it from sustained set since it's now actively pressed
        self.external_sustained_keys.set(note_value, false);
    }

    /// Handle external MIDI note release
    pub fn external_note_off(&mut self, note: Note) {
        let note_value = u8::from(note) as usize;
        debug_assert!(note_value < 128, "MIDI note value must be < 128");

        // Always remove from pressed keys first
        self.external_pressed_keys.set(note_value, false);

        if self.is_sustain_active() {
            // If sustain is active, move the key to sustained set
            self.external_sustained_keys.set(note_value, true);
        }
        // If sustain is not active, the key is simply released (removed from pressed keys above)
    }

    /// Set external sustain pedal state (from MIDI input)
    pub fn set_external_sustain(&mut self, active: bool) {
        self.external_sustain_active = active;
        if !active {
            // When sustain is released, clear all sustained external keys
            self.handle_sustain_release_for_external_keys();
        }
    }

    /// Check if sustain is currently active (either from Shift key or MIDI)
    pub fn is_sustain_active(&self) -> bool {
        self.shift_sustain_active || self.external_sustain_active
    }

    /// Get all keys currently held in some way, from GUI or from MIDI, actively pressed or sustained
    pub fn held_keys(&self) -> KeySet {
        let mut keys = self.current_gui_pressed_keys;

        // Add sustained GUI keys
        for sustained_key in self.sustained_keys.iter_ones() {
            keys.set(sustained_key, true);
        }

        // Add currently active external keys
        for external_key in self.external_pressed_keys.iter_ones() {
            keys.set(external_key % 12, true);
        }

        // Add sustained external keys
        for sustained_key in self.external_sustained_keys.iter_ones() {
            keys.set(sustained_key % 12, true);
        }

        keys
    }

    /// Get the current octave
    pub fn octave(&self) -> u8 {
        self.octave
    }

    /// Generate actions for GUI key state changes
    fn generate_actions_for_gui_keys(&mut self) -> Vec<Action> {
        let mut actions = Vec::new();

        for semitone in Semitone::iter() {
            let note = semitone.to_note_in_octave(self.octave);
            let semitone_index = semitone.as_index();

            let is_pressed = self.current_gui_pressed_keys[semitone_index];
            let was_pressed = self.previous_gui_pressed_keys[semitone_index];

            if is_pressed && !was_pressed {
                actions.push(Action::Pressed(note));
                // If this key was sustained, remove it from sustained set since it's now actively pressed
                self.sustained_keys.set(semitone_index, false);
            } else if !is_pressed && was_pressed {
                if self.is_sustain_active() {
                    // If sustain is active, move to sustained but don't generate Action::Released
                    self.sustained_keys.set(semitone_index, true);
                } else {
                    // If sustain is not active, generate release action and clear sustained
                    actions.push(Action::Released(note));
                    self.sustained_keys.set(semitone_index, false);
                }
            }
        }

        // Update previous state for next frame
        self.previous_gui_pressed_keys = self.current_gui_pressed_keys;

        actions
    }

    /// Handle shift sustain release - release all sustained GUI keys that aren't currently pressed
    fn handle_shift_sustain_release(&mut self) -> Vec<Action> {
        let mut actions = Vec::new();

        for semitone in Semitone::iter() {
            let semitone_index = semitone.as_index();
            let note = semitone.to_note_in_octave(self.octave);
            let is_currently_pressed = self.current_gui_pressed_keys[semitone_index];

            // Clear sustained selection if key is not currently being pressed
            if !is_currently_pressed && self.sustained_keys[semitone_index] {
                self.sustained_keys.set(semitone_index, false);
                actions.push(Action::Released(note));
            }
        }

        actions
    }

    /// Handle sustain pedal release for external (MIDI) keys
    /// Clear all sustained external keys when sustain is released
    fn handle_sustain_release_for_external_keys(&mut self) {
        // Clear all sustained external keys - they should no longer be sustained
        self.external_sustained_keys.fill(false);
    }
}

impl Default for PianoState {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_new_piano_state() {
        let state = PianoState::new();
        assert!(!state.is_sustain_active());
        assert!(state.held_keys().iter_ones().collect::<Vec<_>>().is_empty());
    }

    #[test]
    fn test_gui_key_press_and_release() {
        let mut state = PianoState::new();

        // Press C key (semitone 0)
        let mut pressed_keys = KeySet::default();
        pressed_keys.set(0, true);
        let actions = state.update_gui_keys(pressed_keys);

        assert_eq!(actions.len(), 1);
        assert!(matches!(actions[0], Action::Pressed(_)));
        assert!(state.held_keys()[0]);

        // Release C key
        let pressed_keys = KeySet::default();
        let actions = state.update_gui_keys(pressed_keys);

        assert_eq!(actions.len(), 1);
        assert!(matches!(actions[0], Action::Released(_)));
        assert!(!state.held_keys()[0]);
    }

    #[test]
    fn test_sustain_behavior() {
        let mut state = PianoState::new();

        // Activate sustain
        let actions = state.update_shift_sustain(true);
        assert_eq!(actions.len(), 1);
        assert_eq!(actions[0], Action::SustainPedal(true));
        assert!(state.is_sustain_active());

        // Press and release C key while sustain is active
        let mut pressed_keys = KeySet::default();
        pressed_keys.set(0, true);
        let actions = state.update_gui_keys(pressed_keys);
        assert_eq!(actions.len(), 1);
        assert!(matches!(actions[0], Action::Pressed(_)));

        // Release key while sustain is active - should not generate release action
        let pressed_keys = KeySet::default();
        let actions = state.update_gui_keys(pressed_keys);
        assert!(actions.is_empty());
        assert!(state.held_keys()[0]); // Key should still be held due to sustain

        // Release sustain - should generate release action
        let actions = state.update_shift_sustain(false);
        assert_eq!(actions.len(), 2);
        assert_eq!(actions[0], Action::SustainPedal(false));
        assert!(matches!(actions[1], Action::Released(_)));
        assert!(!state.held_keys()[0]);
    }

    #[test]
    fn test_external_midi_notes() {
        let mut state = PianoState::new();

        // Add external note
        let note = Note::try_from(60).unwrap(); // C4
        state.external_note_on(note);
        assert!(state.held_keys()[0]); // C semitone should be held

        // Release external note
        state.external_note_off(note);
        assert!(!state.held_keys()[0]); // Should no longer be held
    }

    #[test]
    fn test_external_sustain() {
        let mut state = PianoState::new();

        // Set external sustain active
        state.set_external_sustain(true);
        assert!(state.is_sustain_active());

        // Add and release external note while sustain is active
        let note = Note::try_from(60).unwrap(); // C4
        state.external_note_on(note);
        assert!(state.held_keys()[0]);

        state.external_note_off(note);
        assert!(state.held_keys()[0]); // Should still be held due to sustain

        // Release external sustain
        state.set_external_sustain(false);
        assert!(!state.is_sustain_active());
        assert!(!state.held_keys()[0]); // Should no longer be held
    }

    #[test]
    fn test_mixed_sustain_sources() {
        let mut state = PianoState::new();

        // Activate both shift and external sustain
        state.update_shift_sustain(true);
        state.set_external_sustain(true);
        assert!(state.is_sustain_active());

        // Release shift sustain - should still be active due to external
        state.update_shift_sustain(false);
        assert!(state.is_sustain_active());

        // Release external sustain - should no longer be active
        state.set_external_sustain(false);
        assert!(!state.is_sustain_active());
    }
}
