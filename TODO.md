- [x] Add multi-touch support and refactor piano_gui.rs
  - Implemented multi-pointer tracking, updated press/release logic, switched to `wmidi::Note` and `Semitone` types, added debug assertions, refactored state and rendering logic, and verified interval display compatibility.
- [x] Make `shift` act as a sustain pedal
  - Updated GUI and synth to support sustain via shift, fixed sustain logic, changed key press behavior, and improved sustain pedal indication in the GUI.
- [x] Enforce dark mode theme
  - Forced dark mode in theme and app logic.
- [x] Differentiate key states visually in piano_gui
  - Added distinct colors for pressed, sustained, external, and external sustained keys.
- [x] Extend synth sustain duration
  - Reduced decay rate for longer note sustain.
- [x] Refactor piano_gui::Semitone, PointerId, KeySet, and EternalKeySet into a separate file
  - Created `src/piano_types.rs` to house the shared piano-related types: `Semitone`, `PointerId`, `KeySet`, and `ExternalKeySet`. Updated piano_gui.rs to import these types from the new module, removing code duplication and improving modularity.
- [ ] Refactor out non-gui-specific parts of PianoGui into separate type and file so it can be tested properly. I want to be able to test things like what actions are generated when sustain is held in different ways and keys are pressed in different ways, from gui or externally.
  - [x] Refactor `selected_chord_name` from a method to a free function taking `KeySet` - this makes it more testable and doesn't require the full PianoGui instance
  - [x] Create a new `PianoState` struct in `src/piano_state.rs` to handle key state management, sustain logic, and action generation (the non-GUI business logic)
    - Created `src/piano_state.rs` with a comprehensive `PianoState` struct that contains all the business logic for key state management, sustain pedal handling, and action generation. The module includes complete unit tests covering sustain behavior, external MIDI input, GUI key presses, and mixed sustain sources. Also moved shared types to `src/piano_types.rs` for better code organization.
  - [x] Move key state fields (`previous_pressed_keys`, `sustained_keys`, `external_pressed_keys`, `external_sustained_keys`, `shift_sustain_active`, `external_sustain_active`) from `PianoGui` to `PianoState`
    - Successfully moved all key state fields to `PianoState`. Updated `PianoGui` to contain a `PianoState` instance and delegate all business logic calls to it. The `show` method now properly coordinates between GUI events and the underlying `PianoState`, with pointer state converted to key state and actions generated by the state. Re-exported `Action` enum from `piano_gui` for backward compatibility.
  - [ ] Separate GUI state from business logic state: `pointers_holding_key` stays in `PianoGui` (GUI state), but add `current_gui_pressed_keys: KeySet` field to `PianoState` to track which keys are currently pressed via GUI input
  - [ ] Move action generation logic (`generate_actions_for_all_keys`, `Action` enum) from `PianoGui` to `PianoState`
  - [ ] Move external key management methods (`external_note_on`, `external_note_off`, `set_external_sustain`, `handle_sustain_release_for_external_keys`) from `PianoGui` to `PianoState`
  - [ ] Move business logic methods (`held_keys`, `is_sustain_active`) from `PianoGui` to `PianoState`
  - [ ] Update `PianoGui` to contain a `PianoState` instance and delegate business logic calls to it
  - [ ] Keep GUI-specific logic (pointer tracking, rendering, input handling, layout calculations) in `PianoGui`
  - [ ] Update `PianoGui::show` method to coordinate between GUI events and the underlying `PianoState`
  - [ ] Add unit tests for `PianoState` to verify sustain behavior, action generation, and state transitions work correctly without GUI dependencies
- [ ] Keyboard input from the gui should show in the gui, and should result in actions being sent.
- [ ] Keyboard input from midi should only result in keys being marked as pressed in the gui.
- [ ] Sustain pedal activated by shift should result in action to send pedal input to synth.
- [ ] If a keyboard key in the gui is pressed when it is already sustaining due to sustain pedal, noteoff followed by noteon should be sent.
- [ ] sustain action being triggered by shift should be combined with midi sustain in app.rs to make sure that we send sustain pedal message to the synth when either sustain source is pressed, and send stop sustain pedal message to the synth when both sources are released.
- [ ] Figure out why the synth distorts so much (on mobile at least..)
- [ ] Try increasing the reverb to hear how it sounds
- [ ] model piano string stiffness inharmonicity
- [ ] Change the order of the interval displays so the bottom row shows the first pressed note when using the mouse, and the actual base when using a midi keyboard.
  - [ ] The `KeySet` type needs to keep track of the order of the keys
  - [ ] Modify PianoGui to track the chronological order of mouse key presses
  - [ ] Define what "actual base" means for MIDI keyboard input (e.g., lowest note, root note, etc.) Just assume that it is the lowest note for now.
  - [ ] Add input source tracking to distinguish between mouse and MIDI input for each pressed key. If the input modes are mixed, just do some best effort solution. No need to spend much code for this case.
  - [ ] Modify interval_display.rs to use different ordering logic based on input method
  - [ ] Update the pressed_keys data structure to include ordering/priority information
  - [ ] Test the new ordering behavior with both mouse and MIDI input
- [ ] Make the console output from the audio worklet also forward back to the dev server. perhaps we need to have the audio worklet log using a message instead of straight to console
- [ ] Could the midi input callback be moved out of the rust code to make it lower latency?
- [ ] go through the codebase looking for comments that say what has been changed. as is typical of coding agents. remove those as they are not useful longterm
- [ ] Calculate dissonances using critical bands theory (plomp levelt) instead.
    - This would allow us to calculate the dissonance of entire chords
    - how do we handle the fact that we only show a single octave? just force the calculation to happen on a single central octave?
    - can critical bands theory be made octave normalized?
    - does critical bands theory care about the root? do we need to know which note is the root? can the overtones be extended downwards?
- [ ] The dissonance of the currently held notes should show somewhere prominent
- [ ] We only need one row of dissonances that shows what dissonance a new note would result in.
    - for the second note we show the same as we currently do
    - for more notes we show what chord they would result in
