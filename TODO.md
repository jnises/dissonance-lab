- [x] Add multi-touch support and refactor piano_gui.rs
  - Multi-pointer tracking, refactored state/rendering, switched to `wmidi::Note`/`Semitone`, debug assertions, interval display compatibility.
- [x] Make `shift` act as a sustain pedal
  - GUI and synth support for sustain via shift; improved sustain logic and GUI indication.
- [x] Enforce dark mode theme
- [x] Differentiate key states visually in piano_gui
  - Distinct colors for pressed, sustained, and external keys.
- [x] Extend synth sustain duration
  - Reduced decay rate for longer sustain.
- [x] Refactor piano_gui types into `piano_types.rs`
  - Shared types (`Semitone`, `PointerId`, `KeySet`, `ExternalKeySet`) moved for modularity.
- [x] Refactor business logic out of PianoGui into `PianoState`
  - `PianoState` in `piano_state.rs` manages key state, sustain, and actions; GUI delegates logic; comprehensive unit tests.
- [x] Tests for GUI and MIDI input, sustain pedal, and key/sustain interactions
  - Verified correct action generation and GUI state for all input types and sustain scenarios.
- [x] External MIDI notes octave-normalized in GUI
  - MIDI notes from any octave show on correct key; added tests and Semitone constants.
- [x] Combine shift and MIDI sustain sources for synth pedal actions
  - Synth receives pedal on/off only when both sources inactive; order-independent; tested.
- [x] Sustain pedal polarity toggle for MIDI controllers
  - User-toggleable, persists in local storage, fixes inverted pedal behavior.
- [x] Removed agent-generated change-description comments
  - Codebase cleaned of non-useful change logs.
- [x] Replace `#[allow(...)]` with `#[expect(...)]` wherever that makes sense
  - Replaced most `#[allow(dead_code)]` with `#[expect(dead_code)]`; removed attributes where code is actually used; kept `#[allow(dead_code)]` for public API constants provided for convenience
- [ ] model piano string stiffness inharmonicity
- [ ] Change the order of the interval displays so the bottom row shows the first pressed note when using the mouse, and the actual base when using a midi keyboard.
  - [ ] The `KeySet` type needs to keep track of the order of the keys
  - [ ] Modify PianoGui to track the chronological order of mouse key presses
  - [ ] Define what "actual base" means for MIDI keyboard input (e.g., lowest note, root note, etc.) Just assume that it is the lowest note for now.
  - [ ] Add input source tracking to distinguish between mouse and MIDI input for each pressed key. If the input modes are mixed, just do some best effort solution. No need to spend much code for this case.
  - [ ] Modify interval_display.rs to use different ordering logic based on input method
  - [ ] Update the pressed_keys data structure to include ordering/priority information
  - [ ] Test the new ordering behavior with both mouse and MIDI input
- [ ] Could the midi input callback be moved out of the rust code to make it lower latency?
- [ ] Calculate dissonances using critical bands theory (plomp levelt) instead.
    - This would allow us to calculate the dissonance of entire chords
    - how do we handle the fact that we only show a single octave? just force the calculation to happen on a single central octave?
    - can critical bands theory be made octave normalized?
    - does critical bands theory care about the root? do we need to know which note is the root? can the overtones be extended downwards?
- [ ] The dissonance of the currently held notes should show somewhere prominent
- [ ] We only need one row of dissonances that shows what dissonance a new note would result in.
    - for the second note we show the same as we currently do
    - for more notes we show what chord they would result in
- [ ] Make the console output from the audio worklet also forward back to the dev server. perhaps we need to have the audio worklet log using a message instead of straight to console
- [ ] go through the codebase looking for comments that say what has been changed. as is typical of coding agents. remove those as they are not useful longterm
